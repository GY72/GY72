C51 COMPILER V9.54   UART                                                                  08/31/2022 15:02:55 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: D:\Keil5\C51\BIN\C51.EXE ..\src\lib\uart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\uart.lst) TABS(5) OBJECT(.\Objects\uart.obj)

line level    source

   1          /****************************************************************************
   2           * uart.c
   3           *
   4           *    Copyright (C) Hiklife. All rights reserved.
   5           *   Author: Lgx <lgx@hiklife.com> 2019-03
   6           * 
   7           *  uartå¤„ç†å‡½æ•°
   8           *
   9           ****************************************************************************/
  10          #include "..\include_s.h"
  11          
  12          //å›žè°ƒçš„æ•°æ®åŒ…å¤„ç†å‡½æ•°
  13          extern void process_packet(UART_t * c_uart);
  14          
  15          /* ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼*/
  16          /* ï¼ï¼ï¼è¦ç”¨è¿™äº›å‡½æ•°å„UARTä¸­æ–­ä¼˜å…ˆçº§å¿…é¡»ä¸€æ ·ï¼ï¼ï¼*/
  17          /* ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼*/
  18          
  19          /****************************************
  20           * å‡½æ•°åï¼š     uart_send_byte 
  21           * è¯´æ˜Žï¼š   uartå‘é€ï¼Œå†™å…¥sbuf
  22           *             éžä¸­æ–­ä¸­æŽ‰ç”¨æ—¶éœ€è¦ç¡®ä¿å‘é€ä¸­æ–­ä¸ä¼šå‘ç”Ÿï¼Œå› ä¸ºä¸å¯é‡å…¥ï¼
  23           * è¾“å…¥ï¼š   id: uart id, da: å‘é€çš„æ•°æ®
  24           * è¾“å‡ºï¼š   --
  25           ****************************************/
  26          void uart_send_byte(u8 id, u8 da)
  27          {
  28   1           if (id == ID_UART0)
  29   1                SBUF = da;
  30   1           
  31   1           if (id == ID_UART1)
  32   1           {
  33   2                _push_(INSCON);     
  34   2                SETBANK1;
  35   2      
  36   2                SBUF1 = da;
  37   2                
  38   2                SETBANK0;
  39   2                _pop_(INSCON);    
  40   2           }
  41   1           if (id == ID_UART2)
  42   1           {
  43   2                _push_(INSCON);     
  44   2                
  45   2                SETBANK1;
  46   2      
  47   2                SBUF2 = da;
  48   2                
  49   2                SETBANK0;
  50   2                
  51   2                _pop_(INSCON);    
  52   2           }
  53   1      }
  54          /****************************************
C51 COMPILER V9.54   UART                                                                  08/31/2022 15:02:55 PAGE 2   

  55           * å‡½æ•°åï¼š     uart_recv_byte 
  56           * è¯´æ˜Žï¼š   uartæŽ¥æ”¶ï¼Œè¯»å–sbuf
  57           * è¾“å…¥ï¼š   id: uart id
  58           * è¾“å‡ºï¼š   æŽ¥æ”¶åˆ°çš„æ•°æ®
  59           ****************************************/
  60          static u8 uart_recv_byte(u8 id)
  61          {
  62   1           volatile u8 da;
  63   1      
  64   1           if (id == ID_UART0)
  65   1                da = SBUF;
  66   1      
  67   1           if (id == ID_UART1)
  68   1           {
  69   2                _push_(INSCON);
  70   2                SETBANK1;
  71   2      
  72   2                da = SBUF1;
  73   2                
  74   2                SETBANK0;
  75   2                _pop_(INSCON);
  76   2           }
  77   1           if (id == ID_UART2)
  78   1           {
  79   2                _push_(INSCON);
  80   2                SETBANK1;
  81   2      
  82   2                da = SBUF2;
  83   2                
  84   2                SETBANK0;
  85   2                _pop_(INSCON);
  86   2           }
  87   1           return da;
  88   1      }
  89          
  90          
  91          /* ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼*/
  92          /* ï¼ï¼ï¼ï¼ï¼ä¸‹é¢å‡ ä¸ªå‡½æ•°ä¸€èˆ¬ä¸éœ€è¦ä¿®æ”¹ ï¼ï¼ï¼ï¼ï¼!*/
  93          /* ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼*/
  94          
  95          /****************************************
  96           * å‡½æ•°åï¼š     uart_packet_deal
  97           * è¯´æ˜Žï¼š   æŸ¥è¯¢æ˜¯å¦æœ‰ä¸€åŒ…æ•°æ®è¦å¤„ç†ï¼Œè°ƒç”¨process_packetåŒ…å¤„ç†å‡½æ•°ï¼ŒåŠé€šè®¯æ•…éšœè
             -®¡æ•°
  98           *             10msè°ƒç”¨ä¸€æ¬¡
  99           * è¾“å…¥ï¼š   UART_t æŒ‡é’ˆ
 100           * è¾“å‡ºï¼š   --
 101           ****************************************/
 102          static bool panel_packet_check(UART_t * c_uart)
 103          {
 104   1           u8 len, sum;
 105   1           bool check;
 106   1      
 107   1           len = c_uart->rx_buf[1];
 108   1           check = verify_check_crc16(c_uart->rx_buf,len-1);
 109   1           if (check) return true;
 110   1      
 111   1           sum = get_check_sum(c_uart->rx_buf,len-2);
 112   1           if (sum == c_uart->rx_buf[len-1])
 113   1                return true;
 114   1           
 115   1           return false;
C51 COMPILER V9.54   UART                                                                  08/31/2022 15:02:55 PAGE 3   

 116   1      }
 117          
 118          void uart_packet_deal(UART_t * c_uart)
 119          {
 120   1           bool check;
 121   1      
 122   1           if (c_uart->recved_f)
 123   1           {
 124   2                check = panel_packet_check(c_uart);
 125   2                if (check)
 126   2                {
 127   3                     process_packet(c_uart);                           //æ•°æ®åŒ…å¤„ç†
 128   3                }
 129   2      
 130   2                c_uart->recved_f = false;
 131   2           }
 132   1      }
 133          
 134          /****************************************
 135           * å‡½æ•°åï¼š     uart_send_byte_isr
 136           * è¯´æ˜Žï¼š   ä¸€å­—èŠ‚å‘é€å®Œæˆï¼Œå‘é€ä¸‹ä¸€ä¸ªï¼Œå‘é€ä¸­æ–­ä¸­è°ƒç”¨
 137           * è¾“å…¥ï¼š   UART_t æŒ‡é’ˆ
 138           * è¾“å‡ºï¼š   --
 139           ****************************************/
 140          void uart_send_byte_isr(UART_t * c_uart)
 141          {
 142   1           u8 len;
 143   1      
 144   1           if (c_uart->sending_f)
 145   1           {//æ²¡æœ‰å‘é€ä¸­æ–­æˆ–å‘é€ä¸­æ–­æœ‰é—®é¢˜æ—¶ï¼Œåœ¨å¾ªçŽ¯ä¸­å‘é€å¸§å†…æ•°æ®
 146   2                len = c_uart->tx_buf[1];
 147   2      
 148   2                c_uart->tx_ct++;
 149   2                if (c_uart->tx_ct < len)
 150   2                {
 151   3                     uart_send_byte(c_uart->uart_id, c_uart->tx_buf[c_uart->tx_ct]); //51é‡å…¥è­¦å‘Š
 152   3                }
 153   2                else
 154   2                {
 155   3                     c_uart->tx_ct = 0;
 156   3                     c_uart->sending_f = false;                        //ä¸€å¸§æ•°æ®å‘é€å®Œæˆ
 157   3                }
 158   2      
 159   2                return;
 160   2           }
 161   1      
 162   1          c_uart->tx_ct = 0;
 163   1      }
 164          
 165          /****************************************
 166           * å‡½æ•°åï¼š     uart_recv_byte_isr
 167           * è¯´æ˜Žï¼š   æ”¶åˆ°ä¸€ä¸ªå­—èŠ‚, ä¸€èˆ¬åœ¨ä¸­æ–­ä¸­è°ƒç”¨
 168           * è¾“å…¥ï¼š   UART_t æŒ‡é’ˆ
 169           * è¾“å‡ºï¼š   --
 170           ****************************************/
 171          void uart_recv_byte_isr(UART_t * c_uart)
 172          {
 173   1           u8 uart_rx_data;
 174   1           u8 packet_len = 0;
 175   1      
 176   1           /* Receive one date */
 177   1           uart_rx_data = uart_recv_byte(c_uart->uart_id);        //51é‡å…¥
C51 COMPILER V9.54   UART                                                                  08/31/2022 15:02:55 PAGE 4   

 178   1           
 179   1           if(!c_uart->rx_byte_tmr)                                    //æ”¶åˆ°ä¸€å¸§æ•°æ®å¿…é¡»åœ¨è¶…æ—¶æ—¶é—´å†…å¤„ç†ï¼ï¼ï¼
 180   1                  c_uart->rx_ct = 0;                               //last recv byte timeout! reset recv!!!
 181   1           c_uart->rx_byte_tmr = RX_RST_TIME;
 182   1           
 183   1           if (c_uart->recved_f)
 184   1                return;
 185   1                
 186   1           if(!c_uart->rx_ct)
 187   1           {
 188   2                if (uart_rx_data != LEAD_BYTE)
 189   2                     return;
 190   2           }
 191   1      
 192   1           if(c_uart->rx_ct == 1)
 193   1           {
 194   2                if ((uart_rx_data > UART_RX_BYTES) || (uart_rx_data == 0))
 195   2                {//err
 196   3                     c_uart->rx_ct = 0;
 197   3                     return;
 198   3                }
 199   2           }
 200   1      
 201   1           c_uart->rx_buf[c_uart->rx_ct] = uart_rx_data;
 202   1           c_uart->rx_ct++;    
 203   1      
 204   1           if (c_uart->rx_ct >= 2)
 205   1                packet_len = c_uart->rx_buf[1];
 206   1           else
 207   1                return;
 208   1      
 209   1           if (c_uart->rx_ct >= packet_len)
 210   1           {
 211   2                c_uart->rx_ct = 0;            //æ”¶åˆ°ä¸€å¸§
 212   2                c_uart->recved_f = true;    //isr_send_signal(CTRL_TASK_ID);ç»™ä»»åŠ¡ CTRL_TASK_ID å‘ä¿¡å·, ä¸ºäº†ä½¿ç
             -”¨è€Œä½¿ç”¨          
 213   2           }
 214   1      }
 215          
 216          /****************************************
 217           * å‡½æ•°åï¼š     uart_byte_tmr_dn
 218           * è¯´æ˜Žï¼š   msä¸­æ–­ä¸­è°ƒç”¨ , ç»è¿‡RX_RST_TIMEæ¯æŽ¥æ”¶åˆ°1ä¸ªå­—èŠ‚ï¼Œå¤ä½æŽ¥æ”¶.
 219           * è¾“å…¥ï¼š   UART_t æŒ‡é’ˆ
 220           * è¾“å‡ºï¼š   --
 221           ****************************************/
 222          void uart_byte_tmr_dn(UART_t * c_uart)
 223          {
 224   1          //u8_dn(&c_uart->rx_byte_tmr);                     //51é‡å…¥è­¦å‘Š
 225   1           if (c_uart->rx_byte_tmr)
 226   1                c_uart->rx_byte_tmr--;
 227   1      }
 228          
 229          /****************************************
 230           * å‡½æ•°åï¼š     uart_init
 231           * è¯´æ˜Žï¼š   uartåˆå§‹åŒ–å‡½æ•°
 232           * è¾“å…¥ï¼š   UART_t æŒ‡é’ˆ, uart_idåˆ†é…ç»™UART_tæŒ‡é’ˆå¯¹åº”çš„uart
 233           * è¾“å‡ºï¼š   --
 234           ****************************************/
 235          void uart_init(UART_t * c_uart, u8 uart_id)
 236          {
 237   1           c_uart->uart_id   = uart_id;
 238   1          c_uart->sending_f = false;
C51 COMPILER V9.54   UART                                                                  08/31/2022 15:02:55 PAGE 5   

 239   1          c_uart->recved_f  = false;
 240   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    664    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
